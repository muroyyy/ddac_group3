name: Deploy Backend to EC2

on:
  push:
    branches: [dev]
    paths: ['backend/**']
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-southeast-1
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Build and push Docker image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "üê≥ Building Docker image..."
        cd backend
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        echo "üì§ Pushing to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "‚úÖ Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
    
    - name: Deploy to EC2
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        set -e
        
        echo "üöÄ Deploying to EC2..."
        # Create deployment script
        cat > deploy-script.sh << 'SCRIPT_EOF'
#!/bin/bash
set -e

echo "üîç === DEPENDENCY CHECK PHASE ==="
sudo apt update -qq
if ! command -v docker &> /dev/null; then echo "Installing Docker..."; sudo apt install -y docker.io; sudo systemctl start docker; sudo systemctl enable docker; fi
if ! command -v aws &> /dev/null; then echo "Installing AWS CLI v2..."; curl -s https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip; sudo apt install -y unzip; unzip -q awscliv2.zip; sudo ./aws/install; fi
if ! command -v curl &> /dev/null; then sudo apt install -y curl; fi
echo "‚úÖ Dependencies verified"
echo

echo "üîë === ECR LOGIN PHASE ==="
aws ecr get-login-password --region ap-southeast-1 | sudo docker login --username AWS --password-stdin $ECR_REGISTRY || (echo "ECR login failed" && exit 1)
echo "‚úÖ ECR login successful"
echo

echo "üì• === IMAGE PULL PHASE ==="
echo "Pulling image: $ECR_REGISTRY/$ECR_REPOSITORY:latest"
sudo docker pull $ECR_REGISTRY/$ECR_REPOSITORY:latest || (echo "Image pull failed" && exit 1)
echo "‚úÖ Image pulled successfully"
echo

echo "üõë === CONTAINER CLEANUP PHASE ==="
if sudo docker ps -q -f name=bloodline-api; then echo "Stopping existing container..."; sudo docker stop bloodline-api; fi
if sudo docker ps -aq -f name=bloodline-api; then echo "Removing existing container..."; sudo docker rm bloodline-api; fi
echo "‚úÖ Cleanup completed"
echo

echo "üöÄ === CONTAINER START PHASE ==="
echo "Starting container with image: $ECR_REGISTRY/$ECR_REPOSITORY:latest"
CONTAINER_ID=$(sudo docker run -d --name bloodline-api --restart unless-stopped -p 5000:5000 -e ASPNETCORE_ENVIRONMENT=Production $ECR_REGISTRY/$ECR_REPOSITORY:latest)
echo "Container ID: $CONTAINER_ID"
echo "Waiting for container to start..."
sleep 10
echo

echo "üîç === CONTAINER VERIFICATION PHASE ==="
CONTAINER_STATUS=$(sudo docker inspect --format="{{.State.Status}}" bloodline-api)
echo "Container status: $CONTAINER_STATUS"
if [ "$CONTAINER_STATUS" != "running" ]; then echo "Container failed to start" && sudo docker logs bloodline-api && exit 1; fi
echo "‚úÖ Container is running"
echo

echo "üå°Ô∏è === HEALTH CHECK PHASE ==="
echo "Testing port connectivity..."
netstat -tlnp | grep :5000 || (echo "Port 5000 not listening" && exit 1)
echo "Waiting for application startup..."
for i in {1..30}; do if curl -f -s http://localhost:5000/api/health > /dev/null; then break; fi; echo "Attempt $i/30..."; sleep 2; done
HEALTH_RESPONSE=$(curl -f -s http://localhost:5000/api/health)
echo "Health response: $HEALTH_RESPONSE"
if ! echo "$HEALTH_RESPONSE" | grep -q "healthy"; then echo "Health check failed" && sudo docker logs --tail 50 bloodline-api && exit 1; fi
echo "‚úÖ Health check passed"
echo

echo "üìä === DEPLOYMENT SUMMARY ==="
echo "Container name: bloodline-api"
echo "Container status: $(sudo docker inspect --format="{{.State.Status}}" bloodline-api)"
echo "Image: $ECR_REGISTRY/$ECR_REPOSITORY:latest"
echo "Port mapping: $(sudo docker port bloodline-api)"
echo "‚úÖ DEPLOYMENT COMPLETED SUCCESSFULLY!"
SCRIPT_EOF

        # Upload and execute script
        aws s3 cp deploy-script.sh s3://${{ secrets.S3_BUCKET_NAME }}/deploy-script.sh
        
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "export ECR_REGISTRY='$ECR_REGISTRY'",
            "export ECR_REPOSITORY='$ECR_REPOSITORY'",
            "aws s3 cp s3://${{ secrets.S3_BUCKET_NAME }}/deploy-script.sh /tmp/deploy-script.sh",
            "chmod +x /tmp/deploy-script.sh",
            "/tmp/deploy-script.sh"
          ]' \
          --region ap-southeast-1 \
          --query 'Command.CommandId' \
          --output text)
        
        echo "üìã Command ID: $COMMAND_ID"
        
        # Clean up local script
        rm -f deploy-script.sh
        echo "‚è≥ Waiting for deployment..."
        
        # Wait for command completion (increased timeout for comprehensive checks)
        for i in {1..40}; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --region ap-southeast-1 \
            --query 'Status' \
            --output text 2>/dev/null || echo "InProgress")
          
          echo "Status: $STATUS (attempt $i/40)"
          
          if [ "$STATUS" = "Success" ]; then
            echo "‚úÖ Deployment successful!"
            aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
              --region ap-southeast-1 \
              --query 'StandardOutputContent' \
              --output text
            break
          elif [ "$STATUS" = "Failed" ]; then
            echo "‚ùå Deployment failed!"
            aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
              --region ap-southeast-1 \
              --query 'StandardOutputContent' \
              --output text
            exit 1
          fi
          
          sleep 10
        done